Notes for the Tyche Option Strategy Analyzer

Tyche: the presiding deity who governed the fortune and prosperity of a city, its destiny.


ToDos/Issues
============
Need to decide if I want to handle expirations before or after the daily update. Currently doing it after and assuming
expires were left there on purpose

Test: Need to define/create a custom-and-known chain and quote so I can test specific actions.

Input adapter: Current aimed at a modified DeltaNeutral file format. To allow others to play, need to enable other
file types by abstracting the loader and making the chain independent.
Could just have the loader give me the CSV filename, and a mapping of existing column headers to my desired ones... Just
use the pandas.dataframe.rename method. Simple and limiting but good enough!
Will also need to document the expectations of those columns.



Object Model
============

Chain
Cursored view of a symbol's option chains. Provides utility functions around exploring that chain such as finding the
nth nearest expiration for a given date, or the nth strike price up or down from a price, or even filtering the option
set ala query.
It won't provide those functions on the global set as this is a cursored view.

Quote
Similar to the Chain but for stock quotes.

Position - Single instrument with cost and quantity
   Quantity, Symbol, Type, Strike, Expiration, Cost, CurrentPrice, Name (optional)
   Can return the closing Order as a convenience method. Cost is a an average across all the orders that built it.
   Type is Put, Call, Stock (includes ETFs, etc.)

Portfolio - all Positions, open and closed
   Private object of the Broker. Keeps lists of Orders. Can generate a strategy-visible list of Positions.
   Methods include:
      add_position(Position, name=None) appends new Position, closing positions if the opposite exists
        Note that this shouldn't accept price or date. Those should come from the market simulation and chain.
        Assuming this method is not called by the user, but only by the Simulation!
        generates name if none given stupdily for now, then adding a smart suffix based on what is in the named set.
            import namegenerator
            print (namegenerator.gen())
      evaluating a Portfolio and Trade with a Chain
      display() / __str(self)__
      add_position(Order, Price, ExecDate)
      generate_statement(Chain) - the flattened list of currently open positions. effectively read-only.

      Has an internal object type: Order which is one-to-one with each order submitted. Near identical to Position but
      includes the open_date. Order has the ability to generate a position and a static to generate a merged Position
      from orders with the same OPRA code.

      Portfolio computes the balances based on current and closed orders.
      Thus when an option expires, do we set it to the intrinsic value?
      Long options: Absolutely. The current_pl will be correct.
      Short options: These cause sales (calls) or assignments (puts). The cost on those is based on the strike. So,
        after the sale or assignment, the current_pl of the position should provide the balance. So what is the option
        current_pl when we expire it? Well, we got a credit and that didn't actually change, so just keep the cost and
        set the current_pl to the difference between strike and current price of the underlying stock. The assigned
        stock will be marked as purchased at market price and have a current_pl of 0.0.


Strategy
  Base class for implementing a single-symbol strategy. All of the framework user's code goes here (hopefully).
  At least, this is where they interact with Tyche.
  
  All simulation state (positions, balances, etc.) are held in the Simulation. Strategies do not get to modify the
  statements (list of Positions) given to them.
  These two methods define the strategy:
   
     # This method is called once for every day of the backtest.
     # Currently, there are no niceties like being handled a list of actions taken by the market such as expiring 
     # options that are expiring - closing for cash if they are ITM. Only assignment is handled specially.\
     # The method gets the current date, list of positions, current option Chain and corresponding stock Quote. 
     # The last item passed in is the Broker object where the strategy can open/close Positions.
     # Buying power should also be passed in, but since that is a real-time accounting, the Broker also keeps track.
     
     update(date, statement : list of Positions, Chain, Quote, Broker)   

     # This method will be called on a backtest date IFF an option is assigned to the account.
     # The Strategy base class simply iterates over the set of Positions and closes each one.

     assignment(date, list of Position, Chain, Broker)  # Default just closes the assigned position at market value.




Broker
It pretends to be "The Broker." As such, the Strategy asks it to buy and sell and gets it's balances and position
descriptions from there.
To make implementation of update and next_day easier, the Broker provides methods which update the internal set of
Positions and handle the accounting:

   buy([(Position, count)], name=None)
   sell([(Position, count)] | name)
   close([(Position, count)] | name=None)
   
   stock_buying_power():
   option_buying_power():
   net_liquid_value():

   reset():

   _evaluate()
   _load_chains(date, symbol)
   _load_quotes(date, symbol)

   _handle_expirations()

   _chain_frame
   _quote_frame
   _positions {}


Handles:
  * Assignments (assignment probability if desired)
  * Expirations
  * Balances/Drawdowns
  * Commissions
  * Slippage (if desired)





BackTest
Creates the Broker, Strategy and executes the sim loop for a single backtest.
Can re-use the Broker (avoid chain load times) by calling broker.reset()  (or does the chain live with the BackTest?)
Broker is told to execute an iteration for a day by the backtest. Broker handles buys, sells, expirations, assignments.
Broker produces the list of expirations and adjusts positions accordingly. It returns the list of assignments to the
Backtest so it can invoke Strategy.hand_assignments(list of Positions, Broker)
Note that the positions are already in the Portfolio.
BackTest looks at resulting values after end-of-day. If there are no open positions and net liquid is <= 0, then we are
broke and done.



BackTestManager
Runs the backtests. Includes many parameters for things like starting balance, symbols, date ranges,
sampling vs straight run times, slippage and option price evaluation, assignment ramp N days out from expiration, margin multiplier to simulate
portfolio margin, etc.



Predictor - Utility object for Strategies. Low value.
Given a frame and date, predict the stock movement. (Note that theoretically, shouldn't give it all of the frame,
but what-the-hell, it's just for me.) Prediction should be: up (+1), neutral (0), down (-1) and come with some
percent confidence. If there is no measure of confidence, just return 100%.
Strategy decides what to do with the prediction. I.e. if a trend line breaks, the strategy could decide to dump
positions. Of course, it can choose to do that arbitrarily as well. This way, you can plug in different combinations:
    HHHL and Long Synth (can choose to do nothing that way!)
    HHHL and Bear Credit Spreads
    ADX+Vol and the Wheel
    etc.
    predict(frame, date) returns (prediction, confidence)







Count DeMonet: Balances, Margin, Costs, Commissions, Slippage
=============================================================
A Position has both cost and price. Price is the per unit price at time of entry. Cost is the total cost to enter
and should always be quantity * price.
Current_PL is the difference between current price and entry price. Should I just be tracking that instead?

Getting assigned on a Put. If that Put expires ITM, then you end up with stock.
* Do I create the stock position using the Put strike or the current price for that stock?
  If I use the Put strike, the value of the option is now in the stock. For accounting, I should set the value of the
  Put to zero. There is no clear way to see the Put was valuable except in the bottom line.
  This still feels like the right thing to do.










Simulations to Write
====================
Synthetic Long/Short Simulations
  Historical Buys from Fidelity and Robinhood
  Higher-High and Higher-Low combined with ADX>N (N=30 or 35) on S&P 500

  Similarly, compare buying positions 14-21 days out vs 3 mos vs 6 mos.

  Also, investigate rolling the non-spread position (the call in a long synth, the put in a short) when it's Delta
  reaches 0.8 (or thereabouts) and rebuying the ATM strike. Should lock in some profits.

Iron Condor Simulations
  Basic Sasha strategy including the choice to not place an order if there is a trend

Calendar Simulations
  Basic Sasha strategy including the choice to not place an order if there is a trend

The Wheel
  Given an equity, hold it and sell calls at X% ProbITM above.
  When assigned, start selling puts at Y% ProbITM below.
  When assigned, start all over.
  When an option expires worthless, sells another for the next expiration.


Milestones
==========
Write a python app to distribute the zip files into a data lake as described.

Use PyPrind to show simulation status

Add ADX to quote history files

Add a column for ProbITM (stolen from the second post on this page:
https://www.quora.com/How-do-I-calculate-the-probability-of-ITM-for-the-option-contracts )
# From https://www.quora.com/How-do-I-calculate-the-probability-of-ITM-for-the-option-contracts
# It looks like the following in Excel:
#    If StrikePrice < CurrentMarketPrice(CMP)
#        NORMSDIST((LN(StrikePrice /Current_Price)/(ATM_PUT_IV*SQRT(Days_to_Expiry/365))))
#   else if StrikePrice > CurrentMarketPrice(CMP)
#        1-NORMSDIST((LN(StrikePrice /Current_Price)/(ATM_CALL_IV*SQRT(Days_to_Expiry/365))))
# where NORMSDIST is the cumulative norm distribution for a dist mean 0 and stdev 1
print (norm.cdf(math.log(11000/11430) / (.1311 * math.sqrt(47/365)))) # should return 0.207504
print (1 - norm.cdf(math.log(12000/11430) / (.0715 * math.sqrt(47/365)))) # should return 0.02893
Note that I have the IV for each option. I assume that could be used to directly compute ProbITM...



Rando Notes
===========
From bash/cmd
    jupyter notebook --no-browser
    http://localhost:8888

Issue: Does my data have expiring OTM options with current price set to 0.0? Or does that happen the next day?
Ran this to get expiring lines:
awk 'BEGIN { FS = "," } $9==$10 {print $0}' TEAM.csv  | less

